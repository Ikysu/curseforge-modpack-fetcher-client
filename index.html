<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CurseForge Modpack fetcher</title>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <style>
      body {
        background: #121212;
        color: rgb(255 255 255/87%);
        font-family: Roboto, sans-serif;
        line-height: 1.5;
      }

      main {
        margin-left: auto;
        margin-right: auto;
        padding: 1em;
        max-width: 832px;
        min-width: 0;
        width: 100%;
        box-sizing: border-box;
        overflow-wrap: break-word;
      }

      h1,
      h2,
      h3 {
        font-size: 2.25rem;
        line-height: 2.75rem;
        letter-spacing: 0;
      }

      h2,
      h3 {
        font-size: 1.5rem;
        line-height: 2rem;
      }

      select {
        color: rgba(255, 255, 255, 0.644);
        background-color: #121212;
        border: 1px solid rgb(66, 66, 66);
        padding: 0.5em;
        font-size: 1rem;
        box-sizing: border-box;
        width: 10em;
      }

      input {
        color: rgba(255, 255, 255, 0.644);
        background-color: #121212;
        border: 1px solid rgb(66, 66, 66);
        width: 100%;
        padding: 0.5em;
        font-size: 1rem;
        box-sizing: border-box;
      }

      input:focus {
        outline: none;
      }

      input:disabled {
        color: rgba(255, 255, 255, 0.192);
        cursor: not-allowed;
      }

      a {
        color: #90caf9;
        text-decoration: none;
      }

      .error-text {
        color: #cf6679;
      }

      .warn-text {
        color: #cfcd66;
      }

      #search-line {
        display: flex;
      }
      #search-line > input {
        width: auto;
        flex: auto;
      }

      #search-result {
        display: flex;
        flex-direction: column;
        gap: 0.5em;
        padding: 0.5em 0;
      }

      .modpack {
        background-color: #292929;
        display: flex;
        cursor: pointer;
      }

      .modpack > img {
        height: 64px;
        width: 64px;
      }

      .modpack-info {
        padding: 0.2em;
        text-overflow: ellipsis;
        white-space: nowrap;
        overflow: hidden;
      }

      .modpack-info > p {
        line-height: 0;
      }

      .modpack-selected {
        background-color: green;
      }

      button {
        color: #000;
        background-color: #95c4ff;
        font-size: 0.9em;
        font-weight: 700;
        letter-spacing: 0.09em;
        border-radius: 20px;
        border: 0;
        height: 40px;
        padding: 0.5rem 1.5rem;
        cursor: pointer;
      }

      button:hover {
        background-color: #89b4ea;
      }

      button:focus {
        background-color: #7ca3d4;
      }

      button:disabled {
        background-color: rgb(227 226 230/12%);
        color: rgb(227 226 230/38%);
        cursor: not-allowed;
      }

      #build-result {
        max-height: 10em;
        overflow-y: auto;
        white-space: pre-wrap;
      }
    </style>
    <script>
      // UserScripts
      const clearModCacheByModId = async function (modId) {
        const reqs = await window.ModCache.keys();
        reqs
          .filter((req) => req.url.includes(`mod-${modId}`))
          .forEach(async (req) => {
            await window.ModCache.delete(req);
            console.info(`Cache deleted: ${req.url}`);
          });
      };

      const clearModCacheByFilename = async function (filename) {
        const reqs = await window.ModCache.keys();
        return reqs.filter((req) =>
          req.headers.get("x-filename")?.includes(filename)
        );
      };

      const clearModCacheAll = async function () {
        const reqs = await window.ModCache.keys();
        reqs.forEach(async (req) => {
          await window.ModCache.delete(req);
        });
      };
    </script>
    <script>
      // CurseForge API

      class CurseForge {
        endpoint = `https://curseforge.iky.su`;
        request = async (url) => {
          const call = await fetch(`${this.endpoint}/${url}`, {
            headers: { "x-api-key": localStorage.getItem("cfkey") },
            method: "GET",
          })
            .then((response) => ({ response, error: null }))
            .catch((error) => ({ response: null, error }));
          if (call.error) throw new Error(`Fetch error: ${call.error}`);
          let body, json;
          try {
            body = await call.response.text();
            json = JSON.parse(body);
          } catch {}
          if (call.response.status >= 400)
            throw new Error(`Response error ${call.response.status}: ${body}`);
          return json;
        };

        versionsAndLoaders = () => this.request("versions_and_loaders");
        searchModpack = ({ modLoader, version, query }) =>
          this.request(
            `search/${modLoader}/${version}?q=${encodeURIComponent(query)}`
          );
        download = async ({ modId, fileId }) => {
          const call = await fetch(
            `${this.endpoint}/mods/${modId}/files/${fileId}/download`,
            {
              headers: {
                "x-api-key": localStorage.getItem("cfkey"),
              },
            }
          )
            .then((response) => ({ response, error: null }))
            .catch((error) => ({ response: null, error }));
          if (call.error) throw new Error(`Fetch error: ${call.error}`);
          if (call.response.status !== 200)
            throw new Error(await call.response.text());
          return call.response;
        };
        downloadAlt = async ({ modId, fileId }) => {
          const call = await fetch(
            `${this.endpoint}/mods/${modId}/files/${fileId}/download-alt`,
            {
              headers: {
                "x-api-key": localStorage.getItem("cfkey"),
                "x-cookie": localStorage.getItem("cf-cookie"),
              },
            }
          )
            .then((response) => ({ response, error: null }))
            .catch((error) => ({ response: null, error }));
          if (call.error) throw new Error(`Fetch error: ${call.error}`);
          if (call.response.status !== 200)
            throw new Error(await call.response.text());
          return call.response;
        };

        modInfo = ({ modId }) => this.request(`mods/${modId}`);
      }
      const CF2 = new CurseForge();
    </script>
    <script>
      const downloadMod = async ({ modId, fileId, log, alt = false }) => {
        const logWithPrefix = (text) =>
          log(`[Mod: ${modId}/${fileId}] ${text}`);
        const fileCacheName = `mod-${modId}-${fileId}`;
        let fileResponse = await window.ModCache.match(fileCacheName);
        if (!fileResponse) {
          try {
            logWithPrefix(`Downloading`);
            fileResponse = await CF2[alt ? "downloadAlt" : "download"]({
              modId,
              fileId,
            });
          } catch (error) {
            logWithPrefix(`Getting response error: ${String(error)}`);
            return;
          }

          const clonedFileResponse = fileResponse.clone();
          await window.ModCache.put(fileCacheName, clonedFileResponse);
        } else {
          logWithPrefix(`Reading from cache ${fileCacheName}`);
        }

        try {
          blob = await fileResponse.blob();
        } catch (error) {
          logWithPrefix(`Blob error: ${String(error)}`);
          return;
        }

        return {
          blob,
          displayName: fileResponse.headers.get("x-filename"),
          classId: fileResponse.headers.get("x-mod-classid"),
          subfolder: fileResponse.headers.get("x-subfolder"),
        };
      };
    </script>
    <script>
      const buildModpack = async ({ modpack, clear, log }) => {
        clear();
        const file = modpack.latestFiles.at(-1);

        let modpackBlob;
        try {
          log(`[Modpack] Downloading overrides`);
          const { blob } = await downloadMod({
            modId: file.modId,
            fileId: file.id,
            log,
          });
          modpackBlob = blob;
        } catch (error) {
          log(`[Modpack] Fail download overrides: ${error}`);
          return;
        }

        let modpackZip;
        try {
          log(`[Modpack] Reading zip`);
          modpackZip = await JSZip.loadAsync(blob);
        } catch (error) {
          log(`[Modpack] Reading zip error: ${String(error)}`);
          return;
        }

        window.modpackOriginalZip = modpackZip;

        let manifest;
        try {
          const manifestFile = await modpackZip
            .file("manifest.json")
            .async("string");
          manifest = JSON.parse(manifestFile);
        } catch (error) {
          log(`[Modpack] Error reading manifest: ${String(error)}`);
        }

        console.info("Modpack ZIP:", modpackZip);

        console.info("Manifest: ", manifest);
        console.info("Modpack: ", modpack);

        const finalZip = new JSZip();
        let overridesCount = 0;
        for (const path in modpackZip.files) {
          if (!path.startsWith(manifest.overrides)) continue;
          overridesCount++;
          const file = modpackZip.files[path];
          let relativePath = path.slice(manifest.overrides.length);
          if (relativePath.startsWith("/"))
            relativePath = relativePath.slice(1);

          if (file.dir) {
            await finalZip.folder(relativePath);
          } else {
            const content = await file.async("uint8array");
            await finalZip.file(relativePath, content);
          }
        }

        log(
          `[Overrides] Copy done! ${
            Object.keys(finalZip.files).length
          }/${overridesCount}`
        );

        let failedDownloads = [];

        for (const { projectID, fileID } of manifest.files) {
          const mod = await downloadMod({
            modId: projectID,
            fileId: fileID,
            log,
          });

          if (!mod) {
            failedDownloads.push({ projectID, fileID });
            continue;
          }

          const fileName = decodeURIComponent(mod.displayName);
          finalZip.file(`${mod.subfolder}/${fileName}`, mod.blob);
        }

        if (failedDownloads.length) {
          log(
            `[Modpack] Retrying failed downloads (${failedDownloads.length})`
          );

          for (const { projectID, fileID } of failedDownloads) {
            const mod = await downloadMod({
              modId: projectID,
              fileId: fileID,
              log,
              alt: true,
            });

            if (!mod) {
              log(`[Modpack] Stopped.`);
              return;
            }

            const fileName = decodeURIComponent(mod.displayName);
            finalZip.file(`${mod.subfolder}/${fileName}`, mod.blob);
          }
        }

        log(`[Modpack] Done.`);
        const finalBlob = await finalZip.generateAsync({ type: "blob" });
        const exportUrl = URL.createObjectURL(finalBlob);
        // window.location.assign(exportUrl);

        const currentLoader = Number(
          document.getElementById("search-loader")?.value
        );
        const currentVersion = document.getElementById("search-version")?.value;
        const finalZipName = `[${
          window.mcLoaders.find(({ id }) => id === currentLoader)?.name ||
          "Unknown"
        } ${currentVersion || "Unknown"}] ${manifest.name}.zip`;

        const link = document.createElement("a");
        link.href = exportUrl;
        link.download = finalZipName;
        link.click();

        link.remove();
        URL.revokeObjectURL(exportUrl);
      };
    </script>
    <script>
      // Stages utils
      const disables = [
        // Find Minecraft modpack
        [
          () => {
            document.getElementById("cfkey").disabled = false;
          },
          () => {
            document.getElementById("cfkey").disabled = true;
          },
        ],
        [
          () => {
            const searchElement = document.getElementById("search-input");
            searchElement.disabled = false;
            document.getElementById("search-version").disabled = false;
            document.getElementById("search-loader").disabled = false;
          },
          () => {
            const searchElement = document.getElementById("search-input");
            searchElement.value = "";
            searchElement.disabled = true;
            document.getElementById("search-result").innerHTML = "";
            document.getElementById("search-version").disabled = true;
            document.getElementById("search-loader").disabled = true;
          },
        ],
        [
          () => {
            document.getElementById("build-btn").disabled = false;
          },
          () => {
            document.getElementById("build-btn").disabled = true;
          },
        ],
      ];
      const enableAfterStage = (stage) => disables[stage]?.[0]();
      const disableAfterStage = (stage) =>
        disables.slice(stage).forEach((func) => func[1]());
    </script>
    <script>
      // Stage: CurseForge API Key
      const setup1stage = () => {
        const cfkeyElement = document.getElementById("cfkey");
        cfkeyElement.value = localStorage.getItem("cfkey");

        const tokenCheck = async () => {
          disableAfterStage(1);
          cfkeyElement.style.borderColor = "";
          if (cfkeyElement.value?.length === 60) {
            localStorage.setItem("cfkey", cfkeyElement.value);
            try {
              await window.renderMCVersionsAndLoaders();
              cfkeyElement.style.borderColor = "green";
              enableAfterStage(1);
            } catch (error) {
              cfkeyElement.style.borderColor = "red";
              console.info("Token error:", error);
            }
          }
        };
        cfkeyElement.addEventListener("input", tokenCheck);

        const cookieElement = document.getElementById("cookie");
        cookieElement.value = localStorage.getItem("cf-cookie");
        const updateCookie = () =>
          localStorage.setItem("cf-cookie", cookieElement.value);
        cookieElement.addEventListener("input", updateCookie);

        return tokenCheck();
      };
    </script>
    <script>
      // Find Minecraft modpack
      const setup2stage = () => {
        const searchElement = document.getElementById("search-input");
        const searchResultElement = document.getElementById("search-result");
        const searchVersionElement = document.getElementById("search-version");
        const searchLoaderElement = document.getElementById("search-loader");

        window.renderMCVersionsAndLoaders = async () => {
          const { versions, loaders, classIds } =
            await CF2.versionsAndLoaders();
          window.mcVersions = versions;
          window.mcLoaders = loaders;
          window.mcClassIds = classIds;
          searchVersionElement.innerHTML = versions.map(
            ({ versionString }) =>
              `<option value="${versionString}">${versionString}</option>`
          );
          searchLoaderElement.innerHTML = loaders.map(
            ({ id, name }) => `<option value="${id}">${name}</option>`
          );
        };

        const selectModpack = (modpack) => {
          document
            .querySelectorAll(".modpack")
            .forEach((el) => el.classList.remove("modpack-selected"));
          if (modpack) {
            document
              .getElementById(`mp-${modpack.id}`)
              .classList.add("modpack-selected");
            window.selectedModpack = modpack;
            enableAfterStage(2);
          } else {
            disableAfterStage(2);
          }
        };

        let searchTimer;
        const search = async () => {
          if (searchElement.value.length < 3) return;

          let modpacks;
          try {
            const result = await CF2.searchModpack({
              query: searchElement.value,
              version: searchVersionElement.value,
              modLoader: searchLoaderElement.value,
            });
            modpacks = result.slice(0, 15);
          } catch (error) {
            searchResultElement.innerHTML = `<strong class="error-text">${error}</strong>`;
            return;
          }

          searchResultElement.innerHTML = "";
          modpacks.forEach((modpack) => {
            const modpackImage = document.createElement("img");
            modpackImage.src = modpack.logo.thumbnailUrl;

            const modpackTitle = document.createElement("strong");
            modpackTitle.innerText = modpack.name;

            const modpackAuthors = document.createElement("p");
            modpackAuthors.innerText = `by ${modpack.authors
              .map((author) => author.name)
              .join(", ")}`;

            const modpackInfo = document.createElement("div");
            modpackInfo.classList.add("modpack-info");
            modpackInfo.appendChild(modpackTitle);
            modpackInfo.appendChild(modpackAuthors);

            const modpackElement = document.createElement("div");
            modpackElement.classList.add("modpack");
            modpackElement.appendChild(modpackImage);
            modpackElement.appendChild(modpackInfo);
            modpackElement.id = `mp-${modpack.id}`;
            modpackElement.addEventListener("click", () =>
              selectModpack(modpack)
            );

            searchResultElement.appendChild(modpackElement);
          });
        };
        const searchUpdate = () => {
          if (searchElement.value.includes("/minecraft/modpacks/"))
            searchElement.value = searchElement.value.split(
              "/minecraft/modpacks/"
            )[1];
          selectModpack();
          clearTimeout(searchTimer);
          searchTimer = setTimeout(search, 1000);
        };
        searchElement.addEventListener("input", searchUpdate);
        searchVersionElement.addEventListener("change", searchUpdate);
        searchLoaderElement.addEventListener("change", searchUpdate);
      };
    </script>
    <script>
      // Build modpack
      const setup3stage = async () => {
        const buildBtnElement = document.getElementById("build-btn");
        const buildResultElement = document.getElementById("build-result");

        buildBtnElement.addEventListener("click", () =>
          buildModpack({
            modpack: window.selectedModpack,
            clear: () => (buildResultElement.innerText = ""),
            log: (text) => {
              buildResultElement.innerText +=
                new Date().toLocaleTimeString() + " " + text + "\n";
              buildResultElement.scrollTop = buildResultElement.scrollHeight;
            },
          })
        );
      };
    </script>
    <script></script>
  </head>
  <body>
    <main>
      <h1>CurseForge modpack fetcher</h1>
      <p>An easy way to download a client for legacy launcher.</p>
      <p>
        This site isn't designed for searching modpacks. If you want to find a
        suitable modpack for further play, read reviews, descriptions or view
        screenshots, use
        <a href="https://www.curseforge.com/minecraft/search?class=modpacks"
          >official search</a
        >.
      </p>
      <p>
        Also, site doesn't have backend. Mods download directly from CurseForge
        to website cache, so build speed depends on your PC hardware and
        internet speed.
      </p>
      <p>
        <strong class="warn-text">
          Please do not report site errors if you are having problems
          downloading directly from CurseForge.</strong
        >
      </p>
      <section id="api-key">
        <h2>CurseForge API Key</h2>
        <p>
          API key can be generated in the CurseForge for Studios
          <a href="https://console.curseforge.com/">developer console</a>.
        </p>
        <div><input type="text" class="" id="cfkey" placeholder="Token" /></div>
        <p>You can also add a cookie to bypass the download limit.</p>
        <div>
          <input type="text" class="" id="cookie" placeholder="Cookie" />
        </div>
      </section>
      <section id="search">
        <h2>Find Minecraft modpack</h2>
        <p>
          Enter modpack name or URL (like
          https://www.curseforge.com/minecraft/modpacks/...).
        </p>
        <div id="search-line">
          <input
            type="text"
            class=""
            id="search-input"
            placeholder="Search for Minecraft modpacks..."
            disabled
          />
          <select id="search-version" disabled>
            <option value="">Any version</option>
          </select>
          <select id="search-loader" disabled>
            <option value="">Any loader</option>
          </select>
        </div>
        <div id="search-result"></div>
      </section>
      <section id="build-modpack">
        <h2>Build modpack</h2>
        <p>It will take time..</p>
        <button id="build-btn" disabled>Build it!</button>
        <pre id="build-result"></pre>
      </section>
    </main>
    <script>
      window.addEventListener("DOMContentLoaded", async () => {
        window.ModCache = await caches.open("cfmp-fetcher");
        await setup3stage();
        await setup2stage();
        await setup1stage();
      });
    </script>
  </body>
</html>
